##位运算的三个基本操作
* 判断一个数字x二进制下第i位是不是等于1。
方法：if ( ( ( 1 << ( i - 1 ) ) & x ) > 0)
* 将一个数字x二进制下第i位更改成1。
方法：x = x | ( 1<<(i-1) )
* 把一个数字二进制下最靠右的第一个1去掉。
方法：x=x&(x-1)
##题目描述
n个人在做传递物品的游戏,编号为1-n。
游戏规则是这样的：开始时物品可以在任意一人手上，他可把物品传递给其他人中的任意一位；下一个人可以传递给未接过物品的任意一人。
即物品只能经过同一个人一次，而且每次传递过程都有一个代价；不同的人传给不同的人的代价值之间没有联系；
求当物品经过所有n个人后，整个过程的总代价是多少。
##格式
###输入格式
第一行为n,表示共有n个人（16>=n>=2）；
以下为n*n的矩阵，第i+1行、第j列表示物品从编号为i的人传递到编号为j的人所花费的代价，特别的有第i+1行、第i列为-1（因为物品不能自己传给自己），其他数据均为正整数(<=10000)。
(对于50%的数据，n<=11)。
###输出格式
一个数，为最小的代价总和。
##样例1
###样例输入1
2
-1 9794
2724 –1
###样例输出1
2724

##笺释
这道题的关键点在于**以状态做最外层循环**
`   for(int i=0;i<=(1<<n)-1;i++)
    {
        for(int j=0;j<=n-1;j++)
        {
            for(int k=0;k<=n-1;k++)
            {
                if(j!=k)
                {
                if(dp[j][i]+a[j][k]<dp[k][i|1<<k])
                {
                    dp[k][i|1<<k]=dp[j][i]+a[j][k];
                }
                }
            }
        }
    }
`

我本来考虑的是使用

`	while(1)
{
    for(所有已知状态)
    {
        更新未知状态
    }
}
`
但这样的话就遇到了没有办法退出的问题,如果遇到一个满足情况的就退出则无法保证最小。

实际上这道题有个很好的性质：**从前一个状态到后一个状态是通过将某一位上的0换成1造成的,而这个新状态一定排在旧状态的后面。**这个性质给出了**状态更新的单调性**,这也是动态规划思想的本质之一。
考虑之前做过的[垃圾陷阱](https://www.luogu.org/problemnew/show/P1156)这道题中,同样不知道应该在何时退出,但这道题保证了第一个退出的结果一定是所求的最小结果(因为垃圾扔下的时间是递增的,所以第一个能使得奶牛上去的垃圾一定是最小的结果)。因此那道题的单调结构选择的是**按照垃圾扔下的次序单调循环**。
##完整代码
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define MAXN 21
using namespace std;
int n;
int a[MAXN][MAXN];
int dp[MAXN][1<<MAXN];
int main()
{
    scanf("%d",&n);
    for(int i=0;i<=n-1;i++)
    {
        for(int j=0;j<=n-1;j++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=0;i<=n-1;i++)
    {
        dp[i][1<<i]=0;
    }
    for(int i=0;i<=(1<<n)-1;i++)
    {
        for(int j=0;j<=n-1;j++)
        {
            for(int k=0;k<=n-1;k++)
            {
                if(j!=k)
                {
                if(dp[j][i]+a[j][k]<dp[k][i|1<<k])
                {
                    dp[k][i|1<<k]=dp[j][i]+a[j][k];
                }
                }
            }
        }
    }
        int ans=INF;
        for(int i=0;i<=n-1;i++)
        {
            ans=min(ans,dp[i][(1<<n)-1]);
        }
        printf("%d\n",ans);
}
```
